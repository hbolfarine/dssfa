############################################################################################
#
# "Decoupling Shrinkage and Selection in Gaussian Linear Factor Analysis", 2020
# - DSSFA FUNCTION
#
############################################################################################
#
# Author : Henrique Bolfarine
#          Institute of Mathematics and Statistics
#          University of São Paulo
#          Email : bolfarin@ime.usp.br
#
############################################################################################
# 
# Description: Infere the number of factors in the international exchange dataset

#------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------#

# Required Packages
require(Rcpp)
require(inline)
require(fanc)
library(ggplot2)
library(reshape2)
# require(GPArotation)

#------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------#

rcpp_inc <- '
using namespace Rcpp;
using namespace arma;
# '

src.fanc.2 = '
cube OmegaSamp = as<cube>(Mat1);
mat OmegaBar   = as<mat>(Mat2);

int M = size(OmegaSamp)(2);
double val;
double sign;
vec fit(M);

log_det(val,sign,OmegaBar);

for(int i = 0; i < M; i++){
fit(i) = val+trace(inv_sympd(OmegaBar)*OmegaSamp.slice(i));
}

return(wrap(fit));
'
fitcpp.post.fanc.cov = cxxfunction(signature(Mat1 = "numeric",Mat2 = "numeric"), src.fanc.2, plugin='RcppArmadillo', rcpp_inc)

#------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------#

# src.fanc = '
# cube c1      = as<cube>(Mat1);
# mat  m1      = as<mat>(Mat2);
# mat OmegaBar = as<mat>(Mat3);
# 
# int M = size(c1)(2);
# double val;
# double sign;
# vec fit(M);
# 
# log_det(val,sign,OmegaBar);
# 
# for(int i = 0; i < M; i++){
# fit(i) = val+trace(inv_sympd(OmegaBar)*(c1.slice(i)*c1.slice(i).t()+diagmat(m1.row(i))));
# }
# 
# return(wrap(fit));
# '
# fitcpp.post.fanc = cxxfunction(signature(Mat1 = "numeric",Mat2 = "numeric",Mat3 = "numeric"), src.fanc, plugin='RcppArmadillo', rcpp_inc)

#------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------#

src.fanc.1 = '
cube c1 = as<cube>(Mat1);
mat  m2 = as<mat>(Mat2);
mat  OmegaBar = as<mat>(Mat3);

int lambda = size(c1)(2);
vec fit(lambda);
double val;
double sign;

for(int i = 0; i < lambda; i++){
log_det(val,sign,c1.slice(i)+diagmat(m2.row(i)));
fit(i) = val+trace(OmegaBar*inv_sympd(c1.slice(i)+diagmat(m2.row(i))));
}

return(wrap(fit));
'
fitcpp.fanc = cxxfunction(signature(Mat1 = "numeric",Mat2 = "numeric",Mat3 = "numeric"), src.fanc.1, plugin='RcppArmadillo', rcpp_inc)

#------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------#

# Generate the values from the fit function.

fit.fanc.post.cov = function(list.bfa){
  
  list.bfa$fit.post.fanc.cov = fitcpp.post.fanc.cov(list.bfa$post.cov,list.bfa$Omega.kmax)
  return(list.bfa)
  
}

# fit.fanc.post = function(list.bfa){
#   
#   list.bfa$fit.post.fanc = fitcpp.post.fanc(list.bfa$post.loadings,list.bfa$Sigma.post,list.bfa$Omega.kmax)
#   return(list.bfa)
#   
# }

fit.fanc = function(list.bfa){
  
  list.bfa$fit.fanc = fitcpp.fanc(list.bfa$betas.prod.fanc,list.bfa$fanc.sigma,list.bfa$Omega.bar)
  return(list.bfa)
}

#------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------#

# DSSFA function
dssfa.cov = function(obj,length.lambda = 1, k.max = 1, print.out = F, plot.summary = F, cor.factor = F, tol.em = 1e-08){
  
  # cor.factor   = F
  # print.out    = T
  # plot.summary = F
  # 
  # cat("begin-dssa function")
  
  # Melhor colocar ksel aqui tbm, que devolve as matrizes.
  
  if(cor.factor){
    cat("Oblique - Sparse")
    cat("\n")
  }
  
  # Cria Lista - concentra todos o resultados.
  list.bfa = list()
  
  # Prior information
  list.bfa$prior.bfa = obj$prior.bfa
  
  # k.max generated by the bfa method and inference. 
  list.bfa$k.max = k.max
  
  # Posterior sample size.
  list.bfa$M = obj$samp.size
  
  # Model size.
  list.bfa$p = obj$P
  
  # Lenght lambda
  list.bfa$length.lambda = length.lambda
  
  # Modelo Obliquo - booleano, se modelo é obliquo
  list.bfa$cor.factor = cor.factor

  # Posterior Sammples from the Covariance Matrix
  list.bfa$post.cov = obj$post.cov
    
  # Omega.bar = Beta.barBeta.bar'+Sigma.bar (p x p).
  list.bfa$Omega.bar = apply(obj$post.cov,c(1,2),mean)
  
  #----------------------------------------------------------------------------------#
  #----------------------------------------------------------------------------------#
  
  # Generate files that will recieve the fit points for summary plot.
  fit.fanc.mat  = matrix(0,length.lambda,list.bfa$k.max)
  num.zero.mat  = matrix(0,length.lambda,list.bfa$k.max)
  lambda.mat    = matrix(0,length.lambda,list.bfa$k.max)
  fit.sel       = vector("list",list.bfa$k.max)
  num.zero.list = vector("list",list.bfa$k.max)
  list.sel      = vector("list",list.bfa$k.max)
  list.full     = vector("list",list.bfa$k.max)
  uniq.full     = list()
  
  # Files for the correlation matrix of the oblique model.
  if(list.bfa$cor.factor == T){
    phi.full      = list()
    phi.list = vector("list",list.bfa$k.max)
  }
  
  #----------------------------------------------------------------------------------#
  #----------------------------------------------------------------------------------#
  
  for(k.temp in 1:list.bfa$k.max){
    
    # Optimization method.
    
    if(length.lambda >= 2){
      fanc.bfa = fanc(covmat = list.bfa$Omega.bar, factors = k.temp,
                    gamma = Inf, control = list(start = "warm", min.rhozero = T, cor.factor = cor.factor ,length.rho = length.lambda, tol.em = tol.em))
    }else{
      fanc.bfa = fanc(covmat = list.bfa$Omega.bar, factors = k.temp, rho = 0,
                      gamma = Inf, control = list(start = "warm", min.rhozero = T, cor.factor = cor.factor , tol.em = tol.em))
    }
    
    list.bfa$lambda = fanc.bfa$rho
    
    # Lambdas generated by the method given different number of factors.
    lambda.mat[,k.temp] = fanc.bfa$rho
    
    # Generated Loadings (Beta_lambda).
    list.bfa$loadings.fanc.bfa = as.array(fanc.bfa$loadings$gamma1)
    
    # generated Sigma (Sigma_lambda) - para fanc
    list.bfa$fanc.sigma.bfa = fanc.bfa$uniquenesses[,,1]
    
    if(length.lambda < 2){
      list.bfa$fanc.sigma.bfa = matrix(list.bfa$fanc.sigma.bfa,nrow = 1)
    }
    
    fanc.matrix.bfa = matrix(0,length(list.bfa$lambda),list.bfa$p*k.temp)
    for(i in 1:length(list.bfa$lambda)){
      fanc.matrix.bfa[i,] = as.numeric(list.bfa$loadings.fanc.bfa[[i]])
    }
    list.bfa$fanc.matrix.bfa = fanc.matrix.bfa
    
    betas.bfa.fanc.full = replicate(length(list.bfa$lambda),matrix(0,list.bfa$p,k.temp))
    for(i in 1:length(list.bfa$lambda)){
      betas.bfa.fanc.full[,,i] = as.matrix(list.bfa$loadings.fanc.bfa[[i]])
    }
    list.bfa$fanc.matrix.sel = betas.bfa.fanc.full
    
    #----------------------------------------------------------------------------------#
    
    # Verifica quais matrizes possuem colunas iguais a zero.
    mat_dif_zero = which(apply(betas.bfa.fanc.full,3,function(x) sum(colSums(x) == 0)) != 0)
    
    if(length(mat_dif_zero) == length.lambda){
      # In case the 
      cat("Zeroed Columns")
      fanc.bfa  = fanc(covmat = list.bfa$Omega.bar, factors = k.temp, gamma = Inf, control = list(start = "warm", cor.factor = cor.factor, rho = 0,length.rho = 1))
      # fact.gp   = GPFoblq(as.matrix(list.bfa$loadings.fanc.bfa[[length(fanc.bfa$rho)]]))$loadings
      # fact.uniq = fact$uniquenesses
      
      list.bfa$lambda = fanc.bfa$rho
      
      # Lambdas generated by the method given different number of factors.
      lambda.mat[,k.temp] = fanc.bfa$rho
      
      # Generated Loadings (Beta_lambda).
      list.bfa$loadings.fanc.bfa = as.array(fanc.bfa$loadings$gamma1)
      
      # generated Sigma (Sigma_lambda) - para fanc
      list.bfa$fanc.sigma.bfa = t(as.matrix(fanc.bfa$uniquenesses[,,1]))
      
      if(length.lambda < 2){
        list.bfa$fanc.sigma.bfa = matrix(list.bfa$fanc.sigma.bfa,nrow = 1)
      }
      
      fanc.matrix.bfa = matrix(0,length(list.bfa$lambda),list.bfa$p*k.temp)
      for(i in 1:length(list.bfa$lambda)){
        fanc.matrix.bfa[i,] = as.numeric(list.bfa$loadings.fanc.bfa[[i]])
      }
      list.bfa$fanc.matrix.bfa = fanc.matrix.bfa
      
      betas.bfa.fanc.full = replicate(length(list.bfa$lambda),matrix(0,list.bfa$p,k.temp))
      for(i in 1:length(list.bfa$lambda)){
        betas.bfa.fanc.full[,,i] = as.matrix(list.bfa$loadings.fanc.bfa[[i]])
      }
      list.bfa$fanc.matrix.sel = betas.bfa.fanc.full
      
      if(apply(betas.bfa.fanc.full,3,function(x) sum(colSums(x) == 0)) == 0) cat(" - FULL Matrix") else cat("Run method again.")
      
      mat_dif_zero = length.lambda-1
    }
    
    # Numero de elementos diferentes de zero gerado por cada matriz em cada lambda.
    num.zero.mat[,k.temp] = apply(fanc.matrix.bfa, 1, function(x) sum(x != 0))
    
    # Precisa ver pq tem duas listas iguais
    list.sel[[k.temp]]  = betas.bfa.fanc.full
    list.full[[k.temp]] = betas.bfa.fanc.full
    
    if(list.bfa$cor.factor){
      phi.full[[k.temp]] = fanc.bfa$Phi[,,,1]
    }
    
    #----------------------------------------------------------------------------------#
    
    # The product of the loadings from the optimization method.
    betas.prod.bfa.fanc = replicate(length(list.bfa$lambda),matrix(0,list.bfa$p,list.bfa$p))
    # Oblique Product
    if(cor.factor == T & k.temp > 1){
      for(i in 1:length(list.bfa$lambda)){
        betas.prod.bfa.fanc[,,i] = betas.bfa.fanc.full[,,i]%*%fanc.bfa$Phi[,,i,1]%*%t(betas.bfa.fanc.full[,,i])
      }
      list.bfa$betas.prod.fanc = betas.prod.bfa.fanc
      # cat("Phi")
    }else{
      
      # Orthogonal Product
      for(i in 1:length(list.bfa$lambda)){
        betas.prod.bfa.fanc[,,i] = betas.bfa.fanc.full[,,i]%*%t(betas.bfa.fanc.full[,,i])
      }
      list.bfa$betas.prod.fanc = betas.prod.bfa.fanc
    }
    
    #----------------------------------------------------------------------------------#
    
    # Omega and fit distribution generated with k.max.
    if(k.temp == list.bfa$k.max){
      Omega.kmax = list.bfa$betas.prod.fanc[,,length(list.bfa$lambda)]+diag(fanc.bfa$uniquenesses[length(list.bfa$lambda),,1])
      list.bfa$Omega.kmax = Omega.kmax
      list.bfa = fit.fanc.post.cov(list.bfa)
    }
    
    #----------------------------------------------------------------------------------#
    
    # Expected fit points for each lambda.
    list.bfa = fit.fanc(list.bfa)
    fit.fanc.mat[,k.temp] = list.bfa$fit.fanc
    
    #----------------------------------------------------------------------------------#
    
    # Selecting matrices and elements with columns that are different from
    if(length(mat_dif_zero) == 0){
      fit.sel[[k.temp]] = list.bfa$fit.fanc
      num.zero.list[[k.temp]] = apply(fanc.matrix.bfa, 1, function(x) sum(x == 0))
      uniq.full[[k.temp]] = fanc.bfa$uniquenesses[,,1]
      if(length.lambda < 2){
        uniq.full[[k.temp]] = matrix(fanc.bfa$uniquenesses[,,1],nrow = 1)
      }
      
      if(list.bfa$cor.factor == T){
        phi.list[[k.temp]] = fanc.bfa$Phi[,,,1]
      }
      
    }else{
      fit.sel[[k.temp]] = list.bfa$fit.fanc[-mat_dif_zero]
      num.zero.list[[k.temp]] = apply(fanc.matrix.bfa, 1, function(x) sum(x == 0))[-mat_dif_zero]
      if(k.temp == 1){
        dim.array = dim(list.sel[[k.temp]][,,-mat_dif_zero])[2]
        list.sel[[k.temp]] = array(list.sel[[k.temp]][,,-mat_dif_zero],dim = c(list.bfa$p,k.temp,dim.array))
      }else{
        list.sel[[k.temp]] = list.sel[[k.temp]][,,-mat_dif_zero]
        # array(list.sel[[k.temp]][,,-mat_dif_zero],dim = c(list.bfa$p,k.temp,1))
      }
      uniq.full[[k.temp]] = fanc.bfa$uniquenesses[-mat_dif_zero,,1]
      if(length.lambda < 2){
        uniq.full[[k.temp]] = matrix(fanc.bfa$uniquenesses[,,1],nrow = 1)
      }
      
      if(list.bfa$cor.factor == T){
        phi.list[[k.temp]] = fanc.bfa$Phi[,,-mat_dif_zero,1]
      }
    }
    
    #----------------------------------------------------------------------------------#
    
    if(print.out == T){
      cat("Factor = ",k.temp)
      cat("\n")
      # cat(mat_dif_zero)
      # cat("\n")
    }
    
    #----------------------------------------------------------------------------------#
    
  }
  
  if(list.bfa$cor.factor){  
    list.bfa$phi.list = phi.list
    list.bfa$phi.full = phi.full
  }  
  
  list.bfa$uniq.full = uniq.full
  list.bfa$fit.sel = fit.sel
  list.bfa$num.zero.list = num.zero.list
  list.bfa$list.sel = list.sel
  list.bfa$list.full = list.full
  list.bfa$rho.mat = lambda.mat
  
  return(list.bfa)
  
  #----------------------------------------------------------------------------------#
  
}

#------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------#
